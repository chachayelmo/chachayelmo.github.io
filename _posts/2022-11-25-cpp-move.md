---
published: true
title:  "[Programming] C++ move"
excerpt: "C++ì— ëŒ€í•´ ì•Œì•„ë³´ê¸°, move"

categories:
  - Cpp
tags:
  - [C++, Cpp, Move]

toc: true
toc_sticky: true
 
date: 2022-11-25
last_modified_at: 2022-11-25
---

## 1. move
```cpp
template< class T >
typename std::remove_reference<T>::type&& move( T&& t ) noexcept; // (until C++14)
template< class T >
constexpr std::remove_reference_t<T>&& move( T&& t ) noexcept; // (since C++14)
```
- ê°ì²´ tê°€ ì´ë™ ë  ìˆ˜ ìˆìŒ ì„ ì•Œë ¤ì¤Œ
- tê°€ ê°€ì§„ ìì›ì„ ë‹¤ë¥¸ ê°ì²´ì—ê²Œ íš¨ìœ¨ì ìœ¼ë¡œ ì „ë‹¬


## 2. ì½”ë“œë¡œ ì•Œì•„ë³´ê¸°
- [web_compiler](https://godbolt.org/) ì—ì„œ í™•ì¸

### 2.1. ë³µì‚¬ ìƒì„±ìë¥¼ const lvalue referenceë¡œ ë§Œë“œëŠ” ì´ìœ 

```cpp
#include <iostream> 
using namespace std; 
  
class Point 
{ 
  int x = 0; 
  int y = 0; 
public: 
  Point() : x(0), y(0) {} 
  Point(int a, int b) : x(a), y(b) {} 

  // ë³µì‚¬ ìƒì„±ì ëª¨ì–‘
  // 1. call by value, ë³µì‚¬ ìƒì„±ìê°€ ë¬´í•œíˆ í˜¸ì¶œë˜ëŠ” í‘œê¸°ë¼ì„œ ì»´íŒŒì¼ ì—ëŸ¬     
  // 2. call by reference, ì„ì‹œê°ì²´ë¥¼ ë°›ì„ ìˆ˜ ì—†ìŒ, ê°’íƒ€ì…ì„ ë°˜í™˜í•˜ëŠ” í•¨ìˆ˜ì˜ ë¦¬í„´ê°’ì„ ë°›ì„ ìˆ˜ ì—†ìŒ 
  // 3. const lvalue reference 
  Point(const Point& pt) : x(pt.x), y(pt.y) {} 
}; 
Point foo() 
{ 
  Point pt; 
  return pt; 
} 
  
int main() 
{ 
  Point p1; 
  Point p2(1, 2); 
  Point p3(p2);     // Point( Point ) ëª¨ì–‘ì˜ ìƒì„±ì í•„ìš” 
  Point p4 = foo(); // ì„ì‹œê°ì²´ëŠ” rvalueì´ê¸° ë•Œë¬¸ì— ì°¸ì¡°ë¥¼ ë°›ì§€ ëª»í•¨ 
}
```

### 2.2. move ìƒì„±ì ê°œë…

```cpp
#include <iostream>
#include <string.h>
using namespace std; 
  
class Cat 
{ 
  char* name; 
  int   age; 
public: 
  Cat(const char* s, int a) : age(a) 
  { 
    name = new char[strlen(s) + 1]; 
    strcpy(name, s); 
  } 
  // ê¹Šì€ ë³µì‚¬ë¡œ êµ¬í˜„í•œ ë³µì‚¬ ìƒì„±ì 
  Cat(const Cat& c) : age(c.age) 
  { 
    // ë©”ëª¨ë¦¬ í• ë‹¹ í›„, ë©”ëª¨ë¦¬ë¥¼ í†µì§¸ë¡œ ë³µì‚¬ 
    name = new char[strlen(c.name) + 1]; 
    strcpy(name, c.name); 
  } 
  ~Cat() { delete[] name; } 
}; 
int main() 
{ 
  Cat c1("NABI", 2); 
  Cat c2 = c1;
}
```

```cpp
#include <iostream>
#include <string.h>
using namespace std; 
  
class Cat 
{ 
  char* name; 
  int   age; 
public: 
  Cat(const char* s, int a) : age(a) 
  { 
    name = new char[strlen(s) + 1]; 
    strcpy(name, s); 
  } 
  ~Cat() { delete[] name; } 
    
  Cat(const Cat& c) : age(c.age) 
  { 
    cout << "copy" << endl; 
    name = new char[strlen(c.name) + 1]; 
    strcpy(name, c.name); 
  } 

  // ì„ì‹œê°ì²´(rvalue)ë¥¼ ë³µì‚¬í•  ë•Œ ì‚¬ìš©í•  ìƒˆë¡œìš´ ìƒì„±ì 
  // "move" ìƒì„±ì ë¼ê³  ë¶€ë¦„ 
  Cat(Cat&& c) : age(c.age), name(c.name) 
  { 
    cout << "move" << endl; 
    c.name = nullptr; // ì›ë³¸ê°ì²´ì˜ ìì› reset 
  } 
}; 

int main() 
{ 
  Cat c1("NABI", 2); 
  Cat c2 = c1;                        // copy 
  Cat c3 = static_cast<Cat&&>(c2);    // lvalueì§€ë§Œ copy í›„ ì‚­ì œ, move 
  Cat c4 = std::move(c1);             // ìœ„ì²˜ëŸ¼ ìºìŠ¤íŒ…, move
}
```

```cpp
#include <iostream> 
#include <string> 
#include <vector> 
using namespace std; 
  
int main() 
{ 
  string s1 = "hello"; 
  // string s2 = s1; 
  string s2 = std::move(s1); 

  cout << s1 << endl; 

  vector<int> v1(10, 3); 
  // vector<int> v2 = v1; 
  vector<int> v2 = std::move(v1); 

  cout << v1.size() << endl;  // 0 
}
```

### 2.3. move ê°œë… í™œìš©
- í´ë˜ìŠ¤ë¥¼ ë§Œë“¤ ë•Œ ë˜ë„ë¡ move ìƒì„±ìë¥¼ ì œê³µ, ê·¸ë ‡ì§€ ì•Šìœ¼ë©´ ë³µì‚¬ ìƒì„±ìë¥¼ ì‚¬ìš©í•˜ê²Œ ë¨

```cpp
#include <iostream> 
#include <string> 
#include <algorithm> 
using namespace std; 

// moveì™€ ì•Œê³ ë¦¬ì¦˜ 
// ì•„ë˜ ì½”ë“œëŠ” ë³µì‚¬ì— ì˜í•œ swap, ì„±ëŠ¥ ì €í•˜ì˜ ìš”ì¸ 
/* 
template<typename T> void Swap(T& a, T& b) 
{ 
  T tmp = a; 
  a = b; 
  b = tmp; 
} 
*/ 
template<typename T> void Swap(T& a, T& b) 
{ 
  T tmp = std::move(a); 
  a = std::move(b); 
  b = std::move(tmp); 
} 
  
int main() 
{ 
  string s1 = "hello"; 
  string s2 = "world"; 

  Swap(s1, s2); 
}
```

### 2.4. rule of 5
- C++98 : rule of 3 (ì†Œë©¸ì, ë³µì‚¬ìƒì„±ì, ëŒ€ì…ì—°ì‚°ì)
- C++11 : rule of 5 (+ move ìƒì„±ì, move ëŒ€ì…ì—°ì‚°ì)

```cpp
#include <iostream> 
#include <string.h> 
#include <vector> 
using namespace std; 

class Data 
{ 
  int* buff; 
  string str; 
  int data; 
public: 
  Data(string s) : str(s) { buff = new int[100]; } 
  ~Data() { delete[] buff; } 

  // ë³µì‚¬ ìƒì„±ì 
  Data(const Data& d) : str(d.str), data(d.data) 
  { 
    // í¬ì¸í„° ë©¤ë²„ëŠ” ë©”ëª¨ë¦¬ ìì²´ë¥¼ ë³µì‚¬ 
    buff = new int[100]; 
    memcpy(buff, d.buff, sizeof(int) * 100); 
  } 

  // ëŒ€ì… ì—°ì‚°ì 
  Data& operator=(const Data& d) 
  { 
    // ëŒ€ì… ì—°ì‚°ìëŠ” í•­ìƒ ìì‹ ê³¼ì˜ ëŒ€ì…ì„ ì¡°ì‚¬í•´ì•¼ í•¨
    if (&d == this) return *this; 
    str = d.str; 
    data = d.data; 

    // ê¸°ì¡´ ë²„í¼ëŠ” ì œê±°( ë©”ëª¨ë¦¬ í¬ê¸°ê°€ ë‹¤ë¥¼ ìˆ˜ ìˆìœ¼ë¯€ë¡œ )  
    delete[] buff; 
    buff = new int[100]; 
    memcpy(buff, d.buff, sizeof(int) * 100); 

    return *this; 
  } 

  // move ìƒì„±ì 
  Data(Data&& d) : str(std::move(d.str)), data(d.data), buff(d.buff) 
  { 
    d.buff = nullptr; 
  } 

  // move ëŒ€ì… ì—°ì‚°ì 
  Data& operator=(Data&& d) 
  { 
    // ëŒ€ì… ì—°ì‚°ìëŠ” í•­ìƒ ìì‹ ê³¼ì˜ ëŒ€ì…ì„ ì¡°ì‚¬í•´ì•¼ í•¨
    if (&d == this) return *this; 
    str = std::move(d.str); 
    data = d.data; 

    // ê¸°ì¡´ ë²„í¼ëŠ” ì œê±°( ë©”ëª¨ë¦¬ í¬ê¸°ê°€ ë‹¤ë¥¼ ìˆ˜ ìˆìœ¼ë¯€ë¡œ )  
    delete[] buff; 
      
    buff = d.buff; 
    d.buff = nullptr; 
      
    return *this; 
  } 
}; 
  
int main() 
{ 
  Data d1("AA"); 
  //Data d2 = d1; // ë³µì‚¬ ìƒì„±ì 
  Data d3("BB"); 
  d3 = d1; // ëŒ€ì… ì—°ì‚°ì d3.operator=(d1) 
  //d3 = d3; 
}
```

### 2.5. moveì™€ noexcept
- noexcept
  - í•¨ìˆ˜ê°€ ì˜ˆì™¸ê°€ ì—†ë‹¤ê³  ì»´íŒŒì¼ëŸ¬ì—ê²Œ ì•Œë ¤ì£¼ëŠ” ê²ƒ

```cpp
#include <iostream> 
#include <string> 
#include <type_traits> 
#include <vector> 
using namespace std; 
  
class Object 
{ 
  string data; 
public: 
  Object() = default; 
  ~Object() {} 

  Object(const Object& o) : data(o.data)      { cout << "Copy Ctor" << endl; } 

  Object& operator=(const Object& o) 
  { 
    cout << "Copy =" << endl; 
    if (&o == this) return *this; 
    data = o.data; 
    return *this; 
  } 

  // move ê³„ì—´ í•¨ìˆ˜ë¥¼ ë§Œë“¤ ë•Œ 
  // 1. ì˜ˆì™¸ê°€ ì—†ë„ë¡ ë§Œë“¤ê³  
  // 2. í•¨ìˆ˜ () ë’¤ì— noexceptë¥¼ ë¶™ì´ëŠ” ê²ƒì´ ì¢‹ë‹¤. 
  // noexcept : ì˜ˆì™¸ê°€ ì—†ë‹¤. 
  // noexcept(true) : ì˜ˆì™¸ê°€ ì—†ë‹¤. 
  // noexcept(false) : ì˜ˆì™¸ê°€ ìˆë‹¤. 

  Object(Object&& o) noexcept( is_nothrow_move_constructible_v<string> )       
      : data(move(o.data)){ cout << "Move Ctor" << endl; } 

  Object& operator=(Object&& o) noexcept( 
      is_nothrow_move_constructible_v<string>) 
  { 
    cout << "Move =" << endl; 
    if (&o == this) return *this; 
    data = std::move(o.data); 
    return *this; 
  } 
}; 
  
int main() 
{ 
  vector<Object> v(5); 
  v.resize(10); // move ìƒì„±ì 5ë²ˆ, vectorì˜ 5ê°œ objectë¥¼ moveë¡œ ì˜®ê¹€

  Object o1; 
  Object o2 = o1; // ë³µì‚¬ìƒì„±ì 
  Object o3 = std::move(o1); // move ìƒì„±ì 
  Object o4 = std::move_if_noexcept(o2); // ì˜ˆì™¸ê°€ ì—†ìœ¼ë©´ move, ì˜ˆì™¸ê°€ ìˆìœ¼ë©´ ë³µì‚¬ ìƒì„±ì í˜¸ì¶œ 
}
```

### 2.6.  moveì™€ ìƒìˆ˜ê°ì²´
- const ê°ì²´ëŠ” moveê°€ ë  ìˆ˜ ì—†ìŒ, copyê°€ ë¨

```cpp
#include <iostream> 
#include <string> 
#include <type_traits> 
#include <vector> 
using namespace std; 
  
  
class Object 
{ 
  string data; 
public: 
  Object() = default; 
  ~Object() {} 

  Object(const Object& o) : data(o.data) { cout << "Copy Ctor" << endl; } 

  Object& operator=(const Object& o) 
  { 
    cout << "Copy =" << endl; 
    if (&o == this) return *this; 
    data = o.data; 
    return *this; 
  } 

  Object(Object&& o) noexcept : data(move(o.data)) { cout << "Move Ctor" << endl; } 

  Object& operator=(Object&& o ) noexcept 
  { 
    cout << "Move=" << endl; 
    if (&o == this) return *this; 
    data = move(o.data); 
    return *this; 
  } 
}; 
  
// const ê°œì²´ëŠ” move ë  ìˆ˜ ì—†ìŒ!!
int main() 
{ 
  const Object o1; 

  Object o2 = o1;                               // ë³µì‚¬ 
  Object o3 = move(o1);                         // ë³µì‚¬
  Object o4 = static_cast<const Object&&>(o1);  // ë³µì‚¬
}
```

### 2.7. rule of 0
- copy / move ê³„ì—´ì„ ë§Œë“¤ì§€ ì•Šìœ¼ë©´ ì»´íŒŒì¼ëŸ¬ê°€ ëª¨ë‘ ì œê³µ
- copy ê³„ì—´ì„ ì‚¬ìš©ìê°€ ì œê³µí•˜ë©´ ì»´íŒŒì¼ëŸ¬ëŠ” move ê³„ì—´ì„ ì œê³µí•˜ì§€ ì•ŠìŒ
- rule of 0
  - ìì›ì„ ì§ì ‘ ê´€ë¦¬í•˜ì§€ ë§ê³  ìì› ê´€ë¦¬ í´ë˜ìŠ¤ë¥¼ ì‚¬ìš©
  - copy / move ê³„ì—´ì„ ì‚¬ìš©ìê°€ ë§Œë“¤ í•„ìš”ê°€ ì—†ìŒ

```cpp
#include <iostream> 
#include <string> 
#include <type_traits> 
#include <vector> 
using namespace std; 
  
  
class Object 
{ 
  string data; 
public: 
  Object() = default; 
  ~Object() {} 

  Object(const Object& o) : data(o.data) { cout << "Copy Ctor" << endl; } 

  Object& operator=(const Object& o) 
  { 
    cout << "Copy =" << endl; 
    if (&o == this) return *this; 
    data = o.data; 
    return *this; 
  } 

  Object(Object&& o) noexcept : data(move(o.data)) { cout << "Move Ctor" << endl; } 

  Object& operator=(Object&& o)noexcept 
  { 
    cout << "Move =" << endl; 
    if (&o == this) return *this; 
    data = move(o.data); 
    return *this; 
  } 
}; 

class Data 
{ 
  string s;
  vector<int> v;
  Object obj; 
public: 
  Data() = default; 
}; 

int main() 
{ 
  Data d1;
  Data d2 = d1;       // copy
  Data d3 = move(d1); // move
}
```

## ì°¸ê³ 
codenuri ê°•ì„ë¯¼ ê°•ì‚¬ ê°•ì˜ ë‚´ìš©ê¸°ë°˜ìœ¼ë¡œ ì •ë¦¬í•œ ë‚´ìš©ì…ë‹ˆë‹¤.  
[ì½”ë“œëˆ„ë¦¬](https://github.com/codenuri)  
[cppreference](https://en.cppreference.com/w/cpp/utility/move)

<br>

    This is personal diary for study documents.
    Please comment if I'm wrong or missing something else ğŸ˜„. 

[Top](#){: .btn .btn--primary }{: .align-right}