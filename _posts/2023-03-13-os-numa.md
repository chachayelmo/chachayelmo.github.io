---
published: true
title:  "NUMA êµ¬ì¡°"
excerpt: "NUMAì— ëŒ€í•´ ì•Œì•„ë³´ê¸°"

categories:
  - OS
tags:
  - [NUMA, ëˆ„ë§ˆ, êµ¬ì¡°, Architecture]

toc: true
toc_sticky: true
author: chachayelmo
sitemap:
  changefreq : daily
  priority : 1.0
comment: true
date: 2023-03-13
last_modified_at: 2023-03-13
---

## 1. NUMAë€?

- NUMA = Non Uniform Memory Access
- ë©”ëª¨ë¦¬ë¥¼ ê´€ë¦¬í•˜ëŠ” ë°©ë²• ì¤‘ í•˜ë‚˜

### 1.1. UMA

- UMA = Uniform Memory Access

![image](https://user-images.githubusercontent.com/23397039/224652042-68f69767-f90b-466a-b15d-9bb7986bd1ff.png){: .align-center}

- ëª¨ë“  í”„ë¡œì„¸ì„œë“¤ì´ CPUì™€ ë©”ëª¨ë¦¬ ì‚¬ì´ì˜ ê³µìš© BUSë¥¼ ì´ìš©í•´ì„œ ë©”ëª¨ë¦¬ì— ì ‘ê·¼
- ë¬¸ì œì 
    - ì—¬ëŸ¬ ì†Œì¼“ë“¤ì´ BUSë¥¼ ë™ì‹œì— ì‚¬ìš©í•  ìˆ˜ ì—†ë‹¤ëŠ” ì 
    - í•˜ë‚˜ì˜ CPUê°€ ë©”ëª¨ë¦¬ì— ì ‘ê·¼í•˜ê²Œ ë˜ë©´ ë‚˜ë¨¸ì§€ CPUë“¤ì€ block ë˜ì–´ ë©”ëª¨ë¦¬ ì²˜ë¦¬ê°€ ëŠ¦ì–´ì§(ë³‘ëª©í˜„ìƒ)

### 1.2. NUMA

- UMAì˜ ë¬¸ì œë¥¼ í•´ê²°í•˜ê¸° ìœ„í•´ ìƒê²¨ë‚œ ë©”ëª¨ë¦¬ ê´€ë¦¬ ê¸°ë²•

![image](https://user-images.githubusercontent.com/23397039/224652553-6ea59d9e-bd44-4360-805d-85f2cb7c0e24.png){: .align-center}

- ìœ„ ê·¸ë¦¼ì€ NUMA êµ¬ì¡°ë¥¼ í‘œí˜„í•˜ë©°, 4ê°œì˜ CPUë¥¼ ê° ê·¸ë£¹ìœ¼ë¡œ ë‚˜ëˆ„ê³  ë©”ëª¨ë¦¬ ì¼ë¶€ë¥¼ ì—°ê²° ì‹œí‚´
- ë¶„ë¥˜ëœ CPU-ë©”ëª¨ë¦¬ë¥¼ í•˜ë‚˜ì˜ Nodeë¼ê³  ì§€ì¹­í•˜ë©° ë™ì¼í•œ CPU ë‚´ì˜ ë©”ëª¨ë¦¬ ì ‘ê·¼ì€ Local Accessë¼ê³  ë¶€ë¦„
- ì„œë¡œ ë‹¤ë¥¸ Node ê°„ì˜ ë©”ëª¨ë¦¬ ì ‘ê·¼ì€ Remote Access ë¼ê³  ë¶€ë¦„

![image](https://user-images.githubusercontent.com/23397039/224652659-08349146-b975-41b1-ad72-0e55d104d41b.png){: .align-center}

- NUMAëŠ” CPUë³„ë¡œ ì ‘ê·¼í•˜ëŠ” ë©”ëª¨ë¦¬ areaë¥¼ ë‚˜ëˆ„ê¸° ë•Œë¬¸ì— í•´ë‹¹ ë©”ëª¨ë¦¬ë§Œë“¤ ì‚¬ìš©í•˜ë„ë¡ í•˜ì—¬ ë³‘ëª©í˜„ìƒì„ í•´ê²°í•˜ëŠ” ì¥ì ì„ ê°€ì§
- ë‹¤ì‹œ ë§í•´, CPU nê°œë¥¼ í•˜ë‚˜ì˜ NUMA nodeë¡œ ë¬¶ì–´ì„œ ì‚¬ìš©
- NUMA node ë‚´ì—ì„œ ì ‘ê·¼ì„ local accessë¼ê³  í•˜ë©° ê°ê°ì˜ NUMA nodeì—ì„œ ê°ê°ì˜ local accessëŠ” ë™ì‹œì— ì¼ì–´ë‚  ìˆ˜ ìˆê³  ì´ë¥¼ ë°”íƒ•ìœ¼ë¡œ ë³‘ëª©í˜„ìƒì„ í•´ê²°
- NUMAì˜ ì„±ëŠ¥ì€ ì„¤ê³„ì—ì„œ remote accessë¥¼ ê³ ë ¤í•´ì•¼ ë¨
    - Remote accessëŠ” local memory allocation ë“±ì˜ ì‘ì—…ì„ ì§„í–‰í•  ë•Œ ë¬¸ì œê°€ ë°œìƒí•˜ë©´,
    - remote accessê°€ ë°œìƒí•˜ê³  í˜„ì¬ CPUê°€ ì¡´ì¬í•˜ëŠ” NUMA nodeê°€ ì•„ë‹Œ ë‹¤ë¥¸ NUMA nodeì—ì„œ ì‘ì—…ì„ ì²˜ë¦¬
    - ì´ë•Œ ë°œìƒí•˜ëŠ” ì‹œê°„ì ì¸ ì†Œìš”ê°€ 15% ì •ë„ ë‚˜ëŠ” ê²ƒìœ¼ë¡œ ë³´ì„
    - ë”°ë¼ì„œ NUMAë¥¼ ì‚¬ìš©í•  ë•Œ ìµœì í™”ë¥¼ ìœ„í•´ì„œëŠ” ì–´ë–»ê²Œ NUMA nodeë¥¼ ì„¤ê³„í•´ì„œ remote accessë¥¼ ìµœì†Œí™” í•˜ëŠ” ì§€ê°€ ê´€ê±´

## 2. NUMA êµ¬ì¡°

- x86ì—ì„œ NUMA ì‹œìŠ¤í…œì„ ìœ„í•œ ì´ˆê¸°í™” ì„¤ì • ë¶€ë¶„ì€ x86_numa_init í•¨ìˆ˜ì—ì„œ ë™ì‘

```cpp
void __init x86_numa_init(void)
{
	if (!numa_off) {
#ifdef CONFIG_ACPI_NUMA
		if (!numa_init(x86_acpi_numa_init))
			return;
#endif
#ifdef CONFIG_AMD_NUMA
		if (!numa_init(amd_numa_init))
			return;
#endif
	}

	numa_init(dummy_numa_init);
}
```

- numa_init()ì„ í˜¸ì¶œí•˜ê²Œ ë˜ê³  numa_init_array(), numa_set_node() í•¨ìˆ˜ë¥¼ í†µí•´ì„œ CPUì— NUMA Nodeë¥¼ ì„¤ì •
- NUMAì˜ ê° ë©”ëª¨ë¦¬ ë…¸ë“œë“¤ì€ ì•„ë˜ì˜ pglist_dataë¡œ ê´€ë¦¬

```cpp
/*
 * On NUMA machines, each NUMA node would have a pg_data_t to describe
 * it's memory layout. On UMA machines there is a single pglist_data which
 * describes the whole memory.
 *
 * Memory statistics and page replacement data structures are maintained on a
 * per-zone basis.
 */
typedef struct pglist_data {
	struct zone node_zones[MAX_NR_ZONES];
	struct zonelist node_zonelists[MAX_ZONELISTS];
	int nr_zones;
#ifdef CONFIG_FLAT_NODE_MEM_MAP	/* means !SPARSEMEM */
	struct page *node_mem_map;
#ifdef CONFIG_PAGE_EXTENSION
	struct page_ext *node_page_ext;
#endif
#endif
#ifndef CONFIG_NO_BOOTMEM
	struct bootmem_data *bdata;
#endif
#ifdef CONFIG_MEMORY_HOTPLUG
	/*
	 * Must be held any time you expect node_start_pfn, node_present_pages
	 * or node_spanned_pages stay constant.  Holding this will also
	 * guarantee that any pfn_valid() stays that way.
	 *
	 * pgdat_resize_lock() and pgdat_resize_unlock() are provided to
	 * manipulate node_size_lock without checking for CONFIG_MEMORY_HOTPLUG.
	 *
	 * Nests above zone->lock and zone->span_seqlock
	 */
	spinlock_t node_size_lock;
#endif
	unsigned long node_start_pfn;
	unsigned long node_present_pages; /* total number of physical pages */
	unsigned long node_spanned_pages; /* total size of physical page
					     range, including holes */
	int node_id;
	wait_queue_head_t kswapd_wait;
	wait_queue_head_t pfmemalloc_wait;
	struct task_struct *kswapd;	/* Protected by
					   mem_hotplug_begin/end() */
	int kswapd_order;
	enum zone_type kswapd_classzone_idx;

	int kswapd_failures;		/* Number of 'reclaimed == 0' runs */

#ifdef CONFIG_COMPACTION
	int kcompactd_max_order;
	enum zone_type kcompactd_classzone_idx;
	wait_queue_head_t kcompactd_wait;
	struct task_struct *kcompactd;
#endif
#ifdef CONFIG_NUMA_BALANCING
	/* Lock serializing the migrate rate limiting window */
	spinlock_t numabalancing_migrate_lock;

	/* Rate limiting time interval */
	unsigned long numabalancing_migrate_next_window;

	/* Number of pages migrated during the rate limiting time interval */
	unsigned long numabalancing_migrate_nr_pages;
#endif
	/*
	 * This is a per-node reserve of pages that are not available
	 * to userspace allocations.
	 */
	unsigned long		totalreserve_pages;

#ifdef CONFIG_NUMA
	/*
	 * zone reclaim becomes active if more unmapped pages exist.
	 */
	unsigned long		min_unmapped_pages;
	unsigned long		min_slab_pages;
#endif /* CONFIG_NUMA */

	/* Write-intensive fields used by page reclaim */
	ZONE_PADDING(_pad1_)
	spinlock_t		lru_lock;

#ifdef CONFIG_DEFERRED_STRUCT_PAGE_INIT
	/*
	 * If memory initialisation on large machines is deferred then this
	 * is the first PFN that needs to be initialised.
	 */
	unsigned long first_deferred_pfn;
	/* Number of non-deferred pages */
	unsigned long static_init_pgcnt;
#endif /* CONFIG_DEFERRED_STRUCT_PAGE_INIT */

#ifdef CONFIG_TRANSPARENT_HUGEPAGE
	spinlock_t split_queue_lock;
	struct list_head split_queue;
	unsigned long split_queue_len;
#endif

	/* Fields commonly accessed by the page reclaim scanner */
	struct lruvec		lruvec;

	/*
	 * The target ratio of ACTIVE_ANON to INACTIVE_ANON pages on
	 * this node's LRU.  Maintained by the pageout code.
	 */
	unsigned int inactive_ratio;

	unsigned long		flags;

	ZONE_PADDING(_pad2_)

	/* Per-node vmstats */
	struct per_cpu_nodestat __percpu *per_cpu_nodestats;
	atomic_long_t		vm_stat[NR_VM_NODE_STAT_ITEMS];
} pg_data_t;
```

- ê²°êµ­ í•˜ë‚˜ì˜ ë…¸ë“œëŠ” pg_data_t êµ¬ì¡°ì²´ë¥¼ í†µí•´ ê´€ë¦¬ë˜ë©°
- ì´ êµ¬ì¡°ì²´ëŠ” í•´ë‹¹ ë…¸ë“œì— ì†í•´ìˆëŠ” physical ë©”ëª¨ë¦¬ì˜ ì‹¤ì œ ì–‘(node_present_pages)
- physical ë©”ëª¨ë¦¬ê°€ ë©”ëª¨ë¦¬ mapì˜ ëª‡ ë²ˆì§€ì— ìœ„ì¹˜í•˜ê³  ìˆëŠ”ì§€ë¥¼ ë‚˜íƒ€ë‚´ëŠ” ë³€ìˆ˜(node_start_pfn) ë“±ì´ ì •ì˜

![image](https://user-images.githubusercontent.com/23397039/224652734-357ef4de-103e-4f7e-9a45-8b5b2a22054c.png){: .align-center}

## ì°¸ê³ 
[https://wogh8732.tistory.com/399](https://wogh8732.tistory.com/399)  
[https://bluemoon-1st.tistory.com/85](https://bluemoon-1st.tistory.com/85)  
[https://youngswooyoung.tistory.com/64](https://youngswooyoung.tistory.com/64)

<br>

    This is personal diary for study documents.
    Please comment if I'm wrong or missing something else ğŸ˜„. 

[Top](#){: .btn .btn--primary }{: .align-right}